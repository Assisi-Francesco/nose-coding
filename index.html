<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>코 포인터 키보드 - 접근성 코딩 도구</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8rem;
            color: #00d4ff;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .top-section {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-container {
            flex: 2;
            position: relative;
            background: #0f0f23;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #333;
        }

        #video-canvas {
            display: block;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-loading {
            background: #ff9800;
            color: #000;
        }

        .status-ready {
            background: #4caf50;
            color: #fff;
        }

        .blink-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            background: #333;
            color: #666;
            transition: all 0.1s;
        }

        .blink-indicator.active {
            background: #ff4081;
            color: #fff;
            box-shadow: 0 0 20px #ff4081;
        }

        .text-container {
            flex: 1;
            background: #0f0f23;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
        }

        .text-container h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #output-text {
            flex: 1;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 1.1rem;
            color: #0f0;
            min-height: 150px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
        }

        .cursor {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .keyboard-container {
            background: #0f0f23;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #333;
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .keyboard-row {
            display: flex;
            gap: 6px;
        }

        .key {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #2a2a4a, #1a1a2e);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: bold;
            color: #ccc;
            transition: all 0.15s;
            cursor: default;
        }

        .key.hover {
            background: linear-gradient(145deg, #00d4ff, #0099cc);
            border-color: #00d4ff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .key.pressed {
            background: #ff4081;
            border-color: #ff4081;
            transform: scale(0.95);
        }

        .key.space {
            width: 200px;
        }

        .key.backspace, .key.enter {
            width: 80px;
            font-size: 0.9rem;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.85rem;
        }

        .instructions span {
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>코 포인터 키보드</h1>
        <p class="subtitle">코로 포인터를 움직이고, 두 눈을 동시에 깜빡여 입력하세요</p>

        <div class="top-section">
            <div class="video-container">
                <div id="video-canvas"></div>
                <div id="status" class="status-indicator status-loading">모델 로딩중...</div>
                <div id="blink-indicator" class="blink-indicator">눈 깜빡임</div>
            </div>
            <div class="text-container">
                <h3>입력된 텍스트</h3>
                <div id="output-text"><span class="cursor">|</span></div>
            </div>
        </div>

        <div class="keyboard-container">
            <div class="keyboard" id="keyboard"></div>
        </div>

        <p class="instructions">
            <span>코</span>를 움직여 키 위에 포인터를 올리고, <span>두 눈</span>을 동시에 깜빡이면 입력됩니다
        </p>
    </div>

    <script>
        // 전역 변수
        let video;
        let faceMesh;
        let faces = [];
        let noseX = 0, noseY = 0;
        let smoothNoseX = 0, smoothNoseY = 0;
        let isModelReady = false;
        let typedText = '';
        let hoveredKey = null;
        let lastBlinkTime = 0;
        let isBlinking = false;
        let blinkCooldown = 500; // 깜빡임 쿨다운 (ms)

        // 키보드 레이아웃
        const keyboardLayout = [
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
            ['Z', 'X', 'C', 'V', 'B', 'N', 'M'],
            ['SPACE', '⌫', '↵']
        ];

        // 키 정보 저장
        let keyElements = [];
        let keyPositions = [];

        // p5.js 설정
        function setup() {
            const canvas = createCanvas(640, 480);
            canvas.parent('video-canvas');

            // 웹캠 설정
            video = createCapture(VIDEO, videoReady);
            video.size(640, 480);
            video.hide();

            // 키보드 생성
            createKeyboard();
        }

        function videoReady() {
            // FaceMesh 초기화 (ml5.js 0.12.2 API)
            const options = {
                maxFaces: 1,
                refineLandmarks: true,
                flipped: false
            };
            faceMesh = ml5.facemesh(video, options, modelLoaded);
        }

        function modelLoaded() {
            console.log('FaceMesh 모델 로드 완료!');
            isModelReady = true;
            document.getElementById('status').textContent = '준비 완료';
            document.getElementById('status').className = 'status-indicator status-ready';
            faceMesh.on('predict', gotFaces);
        }

        function gotFaces(results) {
            faces = results;
        }

        // 키보드 DOM 생성
        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            keyboard.innerHTML = '';
            keyElements = [];
            keyPositions = [];

            keyboardLayout.forEach((row, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';

                row.forEach((key) => {
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'key';
                    keyDiv.textContent = key;
                    keyDiv.dataset.key = key;

                    if (key === 'SPACE') {
                        keyDiv.classList.add('space');
                        keyDiv.textContent = 'SPACE';
                    } else if (key === '⌫') {
                        keyDiv.classList.add('backspace');
                    } else if (key === '↵') {
                        keyDiv.classList.add('enter');
                    }

                    rowDiv.appendChild(keyDiv);
                    keyElements.push(keyDiv);
                });

                keyboard.appendChild(rowDiv);
            });

            // 위치 업데이트는 draw에서 처리
            setTimeout(updateKeyPositions, 100);
        }

        function updateKeyPositions() {
            keyPositions = keyElements.map(el => {
                const rect = el.getBoundingClientRect();
                return {
                    element: el,
                    key: el.dataset.key,
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    width: rect.width,
                    height: rect.height
                };
            });
        }

        // EAR (Eye Aspect Ratio) 계산
        function calculateEAR(eyePoints) {
            if (!eyePoints || eyePoints.length < 6) return 1;

            // 눈의 수직 거리
            const v1 = dist(eyePoints[1].x, eyePoints[1].y, eyePoints[5].x, eyePoints[5].y);
            const v2 = dist(eyePoints[2].x, eyePoints[2].y, eyePoints[4].x, eyePoints[4].y);

            // 눈의 수평 거리
            const h = dist(eyePoints[0].x, eyePoints[0].y, eyePoints[3].x, eyePoints[3].y);

            if (h === 0) return 1;
            return (v1 + v2) / (2.0 * h);
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // 눈 깜빡임 감지
        function detectBlink(face) {
            if (!face || !face.scaledMesh) return false;

            const mesh = face.scaledMesh;

            // ml5 FaceMesh scaledMesh에서 눈 위치 추출
            // 왼쪽 눈: 33, 160, 158, 133, 153, 144
            // 오른쪽 눈: 362, 385, 387, 263, 373, 380
            const leftEyeIndices = [33, 160, 158, 133, 153, 144];
            const rightEyeIndices = [362, 385, 387, 263, 373, 380];

            const leftEye = leftEyeIndices.map(i => ({ x: mesh[i][0], y: mesh[i][1] }));
            const rightEye = rightEyeIndices.map(i => ({ x: mesh[i][0], y: mesh[i][1] }));

            const leftEAR = calculateEAR(leftEye);
            const rightEAR = calculateEAR(rightEye);

            // 두 눈 모두 임계값 이하일 때 깜빡임으로 판정
            const threshold = 0.2;
            return leftEAR < threshold && rightEAR < threshold;
        }

        // 키 입력 처리
        function handleKeyPress(key) {
            if (key === 'SPACE') {
                typedText += ' ';
            } else if (key === '⌫') {
                typedText = typedText.slice(0, -1);
            } else if (key === '↵') {
                typedText += '\n';
            } else {
                typedText += key.toLowerCase();
            }

            updateOutputText();

            // 키 눌림 효과
            const keyEl = keyElements.find(el => el.dataset.key === key);
            if (keyEl) {
                keyEl.classList.add('pressed');
                setTimeout(() => keyEl.classList.remove('pressed'), 150);
            }
        }

        function updateOutputText() {
            const outputEl = document.getElementById('output-text');
            outputEl.innerHTML = typedText + '<span class="cursor">|</span>';
        }

        // 포인터가 어떤 키 위에 있는지 확인
        function getHoveredKey(screenX, screenY) {
            for (const keyPos of keyPositions) {
                const halfW = keyPos.width / 2;
                const halfH = keyPos.height / 2;

                if (screenX >= keyPos.x - halfW && screenX <= keyPos.x + halfW &&
                    screenY >= keyPos.y - halfH && screenY <= keyPos.y + halfH) {
                    return keyPos;
                }
            }
            return null;
        }

        // p5.js 그리기 루프
        function draw() {
            // 거울 모드로 비디오 그리기
            push();
            translate(width, 0);
            scale(-1, 1);
            image(video, 0, 0, width, height);
            pop();

            if (faces.length > 0 && isModelReady) {
                const face = faces[0];

                // 코 끝 위치 (scaledMesh 인덱스 1)
                if (face.scaledMesh && face.scaledMesh[1]) {
                    const nose = face.scaledMesh[1];

                    // 거울 모드 적용
                    noseX = width - nose[0];
                    noseY = nose[1];

                    // 부드러운 움직임 (스무딩)
                    smoothNoseX += (noseX - smoothNoseX) * 0.3;
                    smoothNoseY += (noseY - smoothNoseY) * 0.3;

                    // 코 위치에 포인터 그리기
                    noStroke();
                    fill(255, 64, 129);
                    ellipse(smoothNoseX, smoothNoseY, 20, 20);

                    // 포인터 주변 링
                    noFill();
                    stroke(255, 64, 129, 150);
                    strokeWeight(2);
                    ellipse(smoothNoseX, smoothNoseY, 30, 30);

                    // 화면 좌표로 변환 (캔버스 → 화면)
                    const canvasRect = document.getElementById('video-canvas').getBoundingClientRect();
                    const screenX = canvasRect.left + smoothNoseX;
                    const screenY = canvasRect.top + smoothNoseY;

                    // 키 위치 업데이트
                    if (frameCount % 30 === 0) {
                        updateKeyPositions();
                    }

                    // 호버된 키 확인
                    const newHoveredKey = getHoveredKey(screenX, screenY);

                    // 호버 상태 업데이트
                    keyElements.forEach(el => el.classList.remove('hover'));
                    if (newHoveredKey) {
                        newHoveredKey.element.classList.add('hover');
                    }
                    hoveredKey = newHoveredKey;

                    // 눈 깜빡임 감지
                    const blinkDetected = detectBlink(face);
                    const blinkIndicator = document.getElementById('blink-indicator');
                    const currentTime = millis();

                    if (blinkDetected && !isBlinking && currentTime - lastBlinkTime > blinkCooldown) {
                        isBlinking = true;
                        lastBlinkTime = currentTime;
                        blinkIndicator.classList.add('active');

                        // 키 입력 처리
                        if (hoveredKey) {
                            handleKeyPress(hoveredKey.key);
                        }
                    } else if (!blinkDetected && isBlinking) {
                        isBlinking = false;
                        blinkIndicator.classList.remove('active');
                    }
                }
            }

            // 안내 텍스트 (얼굴 감지 안됨)
            if (faces.length === 0 && isModelReady) {
                fill(255, 255, 255, 200);
                noStroke();
                textSize(18);
                textAlign(CENTER, CENTER);
                text('얼굴을 카메라에 보여주세요', width / 2, height / 2);
            }
        }

        // 윈도우 리사이즈 시 키 위치 업데이트
        window.addEventListener('resize', () => {
            setTimeout(updateKeyPositions, 100);
        });
    </script>
</body>
</html>
