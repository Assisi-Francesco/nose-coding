<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>코 포인터 키보드 - 접근성 코딩 도구</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8rem;
            color: #00d4ff;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .main-section {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-wrapper {
            flex: 2;
            position: relative;
            background: #0f0f23;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #333;
        }

        #video-canvas {
            display: block;
        }

        /* 키보드 오버레이 - 웹캠 위에 배치 */
        .keyboard-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            pointer-events: none;
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .keyboard-row {
            display: flex;
            gap: 4px;
        }

        .key {
            width: 40px;
            height: 40px;
            background: rgba(30, 30, 60, 0.85);
            border: 2px solid rgba(100, 100, 150, 0.6);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95rem;
            font-weight: bold;
            color: rgba(200, 200, 220, 0.9);
            transition: all 0.15s;
            backdrop-filter: blur(5px);
        }

        .key.hover {
            background: rgba(0, 212, 255, 0.9);
            border-color: #00d4ff;
            color: #000;
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.7);
        }

        .key.pressed {
            background: rgba(255, 64, 129, 0.95);
            border-color: #ff4081;
            transform: scale(0.95);
        }

        .key.space {
            width: 140px;
        }

        .key.backspace, .key.enter {
            width: 60px;
            font-size: 0.8rem;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 20;
        }

        .status-loading {
            background: #ff9800;
            color: #000;
        }

        .status-ready {
            background: #4caf50;
            color: #fff;
        }

        .blink-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            background: rgba(50, 50, 50, 0.8);
            color: #666;
            transition: all 0.1s;
            z-index: 20;
        }

        .blink-indicator.active {
            background: #ff4081;
            color: #fff;
            box-shadow: 0 0 20px #ff4081;
        }

        .text-container {
            flex: 1;
            background: #0f0f23;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
        }

        .text-container h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #output-text {
            flex: 1;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 1.1rem;
            color: #0f0;
            min-height: 150px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
        }

        .cursor {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.85rem;
        }

        .instructions span {
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>코 포인터 키보드</h1>
        <p class="subtitle">코로 포인터를 움직이고, 두 눈을 동시에 깜빡여 입력하세요</p>

        <div class="main-section">
            <div class="video-wrapper">
                <div id="video-canvas"></div>
                <div id="status" class="status-indicator status-loading">모델 로딩중...</div>
                <div id="blink-indicator" class="blink-indicator">눈 깜빡임</div>

                <!-- 키보드 오버레이 -->
                <div class="keyboard-overlay">
                    <div class="keyboard" id="keyboard"></div>
                </div>
            </div>
            <div class="text-container">
                <h3>입력된 텍스트</h3>
                <div id="output-text"><span class="cursor">|</span></div>
            </div>
        </div>

        <p class="instructions">
            <span>코</span>를 움직여 키 위에 포인터를 올리고, <span>두 눈</span>을 동시에 깜빡이면 입력됩니다
        </p>
    </div>

    <script>
        // 전역 변수
        let video;
        let faceMesh;
        let faces = [];
        let noseX = 0, noseY = 0;
        let smoothNoseX = 0, smoothNoseY = 0;
        let isModelReady = false;
        let typedText = '';
        let hoveredKey = null;
        let lastBlinkTime = 0;
        let isBlinking = false;
        let blinkCooldown = 500;

        // 키보드 레이아웃
        const keyboardLayout = [
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
            ['Z', 'X', 'C', 'V', 'B', 'N', 'M'],
            ['SPACE', '⌫', '↵']
        ];

        // 키 정보 저장 (캔버스 좌표 기준)
        let keyElements = [];
        let keyRects = [];

        // p5.js 설정
        function setup() {
            const canvas = createCanvas(640, 480);
            canvas.parent('video-canvas');

            video = createCapture(VIDEO, videoReady);
            video.size(640, 480);
            video.hide();

            createKeyboard();
        }

        function videoReady() {
            const options = {
                maxFaces: 1,
                refineLandmarks: true,
                flipped: false
            };
            faceMesh = ml5.facemesh(video, options, modelLoaded);
        }

        function modelLoaded() {
            console.log('FaceMesh 모델 로드 완료!');
            isModelReady = true;
            document.getElementById('status').textContent = '준비 완료';
            document.getElementById('status').className = 'status-indicator status-ready';
            faceMesh.on('predict', gotFaces);
        }

        function gotFaces(results) {
            faces = results;
        }

        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            keyboard.innerHTML = '';
            keyElements = [];

            keyboardLayout.forEach((row) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';

                row.forEach((key) => {
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'key';
                    keyDiv.textContent = key;
                    keyDiv.dataset.key = key;

                    if (key === 'SPACE') {
                        keyDiv.classList.add('space');
                    } else if (key === '⌫') {
                        keyDiv.classList.add('backspace');
                    } else if (key === '↵') {
                        keyDiv.classList.add('enter');
                    }

                    rowDiv.appendChild(keyDiv);
                    keyElements.push(keyDiv);
                });

                keyboard.appendChild(rowDiv);
            });

            setTimeout(updateKeyRects, 100);
        }

        // 키의 캔버스 좌표 계산
        function updateKeyRects() {
            const canvasEl = document.querySelector('#video-canvas canvas');
            if (!canvasEl) return;

            const canvasRect = canvasEl.getBoundingClientRect();

            keyRects = keyElements.map(el => {
                const rect = el.getBoundingClientRect();
                return {
                    element: el,
                    key: el.dataset.key,
                    // 캔버스 내부 좌표로 변환
                    x: rect.left - canvasRect.left + rect.width / 2,
                    y: rect.top - canvasRect.top + rect.height / 2,
                    width: rect.width,
                    height: rect.height
                };
            });
        }

        function calculateEAR(eyePoints) {
            if (!eyePoints || eyePoints.length < 6) return 1;

            const v1 = dist(eyePoints[1].x, eyePoints[1].y, eyePoints[5].x, eyePoints[5].y);
            const v2 = dist(eyePoints[2].x, eyePoints[2].y, eyePoints[4].x, eyePoints[4].y);
            const h = dist(eyePoints[0].x, eyePoints[0].y, eyePoints[3].x, eyePoints[3].y);

            if (h === 0) return 1;
            return (v1 + v2) / (2.0 * h);
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // EAR 기록 (변화량 감지용)
        let lastLeftEAR = 0;
        let lastRightEAR = 0;
        let earHistory = [];
        const EAR_HISTORY_SIZE = 10;
        let baselineEAR = 0.28; // 기준 EAR (자동 업데이트됨)
        let maxDropValue = 0; // 최대 Drop 값 기록
        let maxDropTime = 0;

        function detectBlink(face) {
            if (!face || !face.scaledMesh) return false;

            const mesh = face.scaledMesh;

            // MediaPipe FaceMesh 눈 랜드마크 인덱스
            const leftEyeTop = [159, 145];
            const leftEyeBottom = [153, 144];
            const leftEyeLeft = 33;
            const leftEyeRight = 133;

            const rightEyeTop = [386, 374];
            const rightEyeBottom = [380, 373];
            const rightEyeLeft = 362;
            const rightEyeRight = 263;

            // 왼쪽 눈 EAR
            const leftV1 = dist(mesh[leftEyeTop[0]][0], mesh[leftEyeTop[0]][1], mesh[leftEyeBottom[0]][0], mesh[leftEyeBottom[0]][1]);
            const leftV2 = dist(mesh[leftEyeTop[1]][0], mesh[leftEyeTop[1]][1], mesh[leftEyeBottom[1]][0], mesh[leftEyeBottom[1]][1]);
            const leftH = dist(mesh[leftEyeLeft][0], mesh[leftEyeLeft][1], mesh[leftEyeRight][0], mesh[leftEyeRight][1]);
            const leftEAR = leftH > 0 ? (leftV1 + leftV2) / (2.0 * leftH) : 1;

            // 오른쪽 눈 EAR
            const rightV1 = dist(mesh[rightEyeTop[0]][0], mesh[rightEyeTop[0]][1], mesh[rightEyeBottom[0]][0], mesh[rightEyeBottom[0]][1]);
            const rightV2 = dist(mesh[rightEyeTop[1]][0], mesh[rightEyeTop[1]][1], mesh[rightEyeBottom[1]][0], mesh[rightEyeBottom[1]][1]);
            const rightH = dist(mesh[rightEyeLeft][0], mesh[rightEyeLeft][1], mesh[rightEyeRight][0], mesh[rightEyeRight][1]);
            const rightEAR = rightH > 0 ? (rightV1 + rightV2) / (2.0 * rightH) : 1;

            const avgEAR = (leftEAR + rightEAR) / 2;

            lastLeftEAR = leftEAR;
            lastRightEAR = rightEAR;

            // EAR 히스토리 저장
            earHistory.push(avgEAR);
            if (earHistory.length > EAR_HISTORY_SIZE) {
                earHistory.shift();
            }

            // 기준선 업데이트 (최근 값들의 최대값)
            if (earHistory.length >= EAR_HISTORY_SIZE) {
                const maxRecent = Math.max(...earHistory);
                baselineEAR = baselineEAR * 0.95 + maxRecent * 0.05;
            }

            // 변화량 기반 감지: 기준선 대비 0.5% 이상 감소하면 깜빡임
            const dropThreshold = 0.005;
            const drop = baselineEAR - avgEAR;

            return drop > dropThreshold;
        }

        function handleKeyPress(key) {
            if (key === 'SPACE') {
                typedText += ' ';
            } else if (key === '⌫') {
                typedText = typedText.slice(0, -1);
            } else if (key === '↵') {
                typedText += '\n';
            } else {
                typedText += key.toLowerCase();
            }

            updateOutputText();

            const keyEl = keyElements.find(el => el.dataset.key === key);
            if (keyEl) {
                keyEl.classList.add('pressed');
                setTimeout(() => keyEl.classList.remove('pressed'), 150);
            }
        }

        function updateOutputText() {
            const outputEl = document.getElementById('output-text');
            outputEl.innerHTML = typedText + '<span class="cursor">|</span>';
        }

        // 캔버스 좌표 기준으로 키 확인
        function getHoveredKey(canvasX, canvasY) {
            for (const keyRect of keyRects) {
                const halfW = keyRect.width / 2;
                const halfH = keyRect.height / 2;

                if (canvasX >= keyRect.x - halfW && canvasX <= keyRect.x + halfW &&
                    canvasY >= keyRect.y - halfH && canvasY <= keyRect.y + halfH) {
                    return keyRect;
                }
            }
            return null;
        }

        function draw() {
            // 거울 모드로 비디오 그리기
            push();
            translate(width, 0);
            scale(-1, 1);
            image(video, 0, 0, width, height);
            pop();

            if (faces.length > 0 && isModelReady) {
                const face = faces[0];

                if (face.scaledMesh && face.scaledMesh[1]) {
                    const nose = face.scaledMesh[1];

                    // 거울 모드 적용
                    noseX = width - nose[0];
                    noseY = nose[1];

                    // 스무딩
                    smoothNoseX += (noseX - smoothNoseX) * 0.3;
                    smoothNoseY += (noseY - smoothNoseY) * 0.3;

                    // 포인터 그리기
                    noStroke();
                    fill(255, 64, 129);
                    ellipse(smoothNoseX, smoothNoseY, 20, 20);

                    noFill();
                    stroke(255, 64, 129, 150);
                    strokeWeight(2);
                    ellipse(smoothNoseX, smoothNoseY, 30, 30);

                    // 키 위치 업데이트
                    if (frameCount % 30 === 0) {
                        updateKeyRects();
                    }

                    // 캔버스 좌표로 호버 확인
                    const newHoveredKey = getHoveredKey(smoothNoseX, smoothNoseY);

                    keyElements.forEach(el => el.classList.remove('hover'));
                    if (newHoveredKey) {
                        newHoveredKey.element.classList.add('hover');
                    }
                    hoveredKey = newHoveredKey;

                    // 눈 깜빡임 감지
                    const blinkDetected = detectBlink(face);
                    const blinkIndicator = document.getElementById('blink-indicator');
                    const currentTime = millis();

                    if (blinkDetected && !isBlinking && currentTime - lastBlinkTime > blinkCooldown) {
                        isBlinking = true;
                        lastBlinkTime = currentTime;
                        blinkIndicator.classList.add('active');
                        console.log('눈 깜빡임 감지!', hoveredKey ? hoveredKey.key : '키 없음');

                        if (hoveredKey) {
                            handleKeyPress(hoveredKey.key);
                            console.log('키 입력:', hoveredKey.key);
                        }
                    } else if (!blinkDetected && isBlinking) {
                        isBlinking = false;
                        blinkIndicator.classList.remove('active');
                    }
                }
            }

            // EAR 디버깅 표시
            if (isModelReady && faces.length > 0) {
                const avgEAR = (lastLeftEAR + lastRightEAR) / 2;
                const drop = baselineEAR - avgEAR;

                // 최대 Drop 값 기록 (3초간 유지)
                if (drop > maxDropValue) {
                    maxDropValue = drop;
                    maxDropTime = millis();
                }
                if (millis() - maxDropTime > 3000) {
                    maxDropValue = 0;
                }

                fill(255, 255, 255);
                noStroke();
                textSize(12);
                textAlign(LEFT, TOP);
                text(`AVG EAR: ${avgEAR.toFixed(3)}`, 10, 45);
                text(`Baseline: ${baselineEAR.toFixed(3)}`, 10, 60);
                text(`Drop: ${drop.toFixed(3)}`, 10, 75);

                // 최근 최대 Drop 값 표시
                fill(255, 255, 0);
                text(`Max Drop (3s): ${maxDropValue.toFixed(3)}`, 10, 90);

                // 감지 여부 표시
                if (drop > 0.005) {
                    fill(0, 255, 0);
                    text(`BLINK!`, 10, 105);
                }
            }

            if (faces.length === 0 && isModelReady) {
                fill(255, 255, 255, 200);
                noStroke();
                textSize(18);
                textAlign(CENTER, CENTER);
                text('얼굴을 카메라에 보여주세요', width / 2, height / 2);
            }
        }

        window.addEventListener('resize', () => {
            setTimeout(updateKeyRects, 100);
        });

        // 키보드 단축키
        window.addEventListener('keydown', (e) => {
            // 스페이스바: 호버된 키 입력
            if (e.code === 'Space' && hoveredKey) {
                e.preventDefault();
                handleKeyPress(hoveredKey.key);
                console.log('스페이스바로 입력:', hoveredKey.key);
            }
            // 백스페이스: 텍스트 삭제
            if (e.code === 'Backspace') {
                e.preventDefault();
                typedText = typedText.slice(0, -1);
                updateOutputText();
                console.log('백스페이스로 삭제');
            }
        });
    </script>
</body>
</html>
